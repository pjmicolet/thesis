\relax 
\@writefile{toc}{\contentsline {chapter}{\numberline {7}New fetching scheme and data speculation for improved performance}{117}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{loa}{\addvspace {10\p@ }}
\newlabel{chp:hardchanges}{{7}{117}}
\@writefile{toc}{\contentsline {section}{\numberline {7.1}Introduction}{117}}
\newlabel{sect:introduction-chapter3}{{7.1}{117}}
\citation{peraisBeBop2015}
\citation{robatmili2011uniproc}
\citation{kim2007tflex}
\citation{robatmili2011uniproc}
\citation{peraisBeBop2015}
\citation{sdvbs}
\@writefile{lof}{\contentsline {figure}{\numberline {7.1}{\ignorespaces Left: Speedup obtained when executing the MSER benchmark on different compositions and branch prediction accuracies. Right: Percentage of time (in cycles) cores in a composition execute instructions compared to the overall execution time. Higher is better for both.\relax }}{120}}
\newlabel{fig:mser_motiv}{{7.1}{120}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.2}{\ignorespaces Speedup obtained when executing the MSER benchmark with different core composition with an oracle fetching scheme and perfect branch prediction. Higher is better. \relax }}{120}}
\newlabel{fig:motivation_fetch}{{7.2}{120}}
\@writefile{toc}{\contentsline {section}{\numberline {7.2}Motivation}{120}}
\newlabel{sect:ch3-motivation}{{7.2}{120}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.2.1}Branch prediction}{120}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.2.2}Fetching mechanism}{121}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {7.1}{\ignorespaces Example of loop found in MSER.\relax }}{122}}
\newlabel{lst:mser_snipet}{{7.1}{122}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {7.2}{\ignorespaces Example of how data-dependencies cause delays when executing four blocks in parallel. The blocks represent part of the loop body in Listing\nobreakspace  {}7.1\hbox {}.\relax }}{122}}
\newlabel{fig:mser_nvsited}{{7.2}{122}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.2.3}Data dependencies between blocks}{122}}
\citation{peraisVTAGE2014}
\@writefile{lof}{\contentsline {figure}{\numberline {7.3}{\ignorespaces Speedup of executing \textit  {MSER} using the new fetching mechanism, with perfect value prediction and perfect branch prediction. Baseline is a single core with original branch prediction accuracy. Higher is better.\relax }}{123}}
\newlabel{fig:motivation_reg}{{7.3}{123}}
\@writefile{toc}{\contentsline {section}{\numberline {7.3}Round robin block fetching scheme}{123}}
\newlabel{chp3:sec:fetch}{{7.3}{123}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.3.1}Current fetching scheme}{123}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {7.3}{\ignorespaces Example of small loop.\relax }}{124}}
\newlabel{lst:basic}{{7.3}{124}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {7.4}{\ignorespaces Trace of when cores fetch blocks when executing Listing\nobreakspace  {}7.3\hbox {} on a 4 core composition. Y axis represents a core in the composition, X axis represents time.\relax }}{124}}
\newlabel{fig:fetch_norm}{{7.4}{124}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.3.2}Round Robin Fetching Scheme}{124}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {7.3.2.1}Generalised form}{124}}
\citation{SeznecMultipleBlock}
\@writefile{loa}{\contentsline {algocf}{\numberline {1}{\ignorespaces Overview of fetching algorithm for \textit  {n} cores fused\relax }}{126}}
\newlabel{alg:fetch}{{1}{126}}
\@writefile{loa}{\contentsline {algocf}{\numberline {2}{\ignorespaces Overview of commit stage for \textit  {n} cores fused\relax }}{127}}
\newlabel{alg:commit}{{2}{127}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.4}{\ignorespaces Example of RRF on a 2 core composition. Each core has 4 segments, the arrows represent the block generating the predictions.\relax }}{127}}
\newlabel{fig:new_fetch_ex}{{7.4}{127}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.5}{\ignorespaces Speedup when executing the synthetic block with varying execution times (facets) with SF and RRF. Higher is better.\relax }}{128}}
\newlabel{fig:motiv_res}{{7.5}{128}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.6}{\ignorespaces Average execution time (in cycles) of blocks for the SD-VBS benchmarks. Each benchmark is executed on one core with perfect branch prediction.\relax }}{128}}
\newlabel{fig:svdbs_av}{{7.6}{128}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.3.3}Evaluating the round robin fetch scheme on a synthetic block}{128}}
\@writefile{toc}{\contentsline {section}{\numberline {7.4}Value Predictor}{129}}
\citation{peraisVTAGE2014}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {7.5}{\ignorespaces Example of small loop.\relax }}{130}}
\newlabel{lst:basic2}{{7.5}{130}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.7}{\ignorespaces Overview of how a value predictor should work for EDGE. Prediction is made at the fetch stage, and predictions are used when register reads are dispatched.\relax }}{130}}
\newlabel{fig:bad_overview}{{7.7}{130}}
\citation{peraisBeBop2015}
\citation{peraisBeBop2015}
\citation{peraisBeBop2015}
\citation{peraisVTAGE2014}
\citation{peraisBeBop2015}
\citation{gabbayVPOrig}
\citation{goeman01dfcm}
\citation{peraisBeBop2015}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.4.1}Design features of a value predictor}{131}}
\citation{peraisBeBop2015}
\citation{peraisBeBop2015}
\citation{peraisVTAGE2014}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.4.2}Block based D-VTAGE predictor}{132}}
\citation{peraisBeBop2015}
\citation{sdvbs}
\newlabel{chp3:sec:val}{{7.4.2}{133}}
\@writefile{toc}{\contentsline {section}{\numberline {7.5}Experimental Setup}{133}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.5.1}Benchmarks}{133}}
\citation{peraisVTAGE2014}
\citation{peraisBeBop2015}
\citation{sheikh2017value}
\citation{peraisBeBop2015}
\@writefile{lot}{\contentsline {table}{\numberline {7.1}{\ignorespaces Datasets used for each of the benchmarks.\relax }}{134}}
\newlabel{tab:sd-data2}{{7.1}{134}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.5.2}Evaluation}{134}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.5.3}Value Predictor}{134}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.8}{\ignorespaces Overview of information gathering for generating traces which are used for the perfect branch and value predictors.\relax }}{135}}
\newlabel{fig:trace-gen}{{7.8}{135}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.9}{\ignorespaces Overview of how the trace data generated for value prediction is used during execution of a block.\relax }}{135}}
\newlabel{fig:trace-used}{{7.9}{135}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.5.4}Implementing perfect value and branch predictor}{135}}
\newlabel{chp:chp3:sec:exp}{{7.5.4}{135}}
\@writefile{toc}{\contentsline {section}{\numberline {7.6}Analysis using a perfect value prediction}{136}}
\newlabel{chp:chp3:sec:analysis}{{7.6}{136}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.6.1}Analysing the performance of the different configurations}{136}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {7.6.1.1}Performance without value prediction}{136}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.10}{\ignorespaces Comparing the performance of serial fetch to round robin fetch, with and without perfect value prediction. Higher is better\relax }}{137}}
\newlabel{fig:perf_pred}{{7.10}{137}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.11}{\ignorespaces Average time each core is executing blocks (in \%) for each benchmark, using the different configurations. Higher is better.\relax }}{137}}
\newlabel{fig:perf_av_cycle}{{7.11}{137}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {7.6.1.2}Performance with value prediction}{137}}
\citation{peraisBeBop2015}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {7.6.1.3}Summary}{138}}
\citation{peraisBeBop2015}
\@writefile{lof}{\contentsline {figure}{\numberline {7.12}{\ignorespaces Number of blocks that cause LSQ violations, normalised by the number of fetched blocks for each of the benchmarks.\relax }}{139}}
\newlabel{fig:lsqvio}{{7.12}{139}}
\@writefile{toc}{\contentsline {section}{\numberline {7.7}Analysis using the block based D-VTAGE predictor}{139}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.7.1}Block analysis}{139}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.13}{\ignorespaces Average number of register reads and writes per EDGE block and the number of unique blocks comprising different percentages of the total execution (in blocks) of each of the benchmarks.\relax }}{140}}
\newlabel{fig:edge_reg_read}{{7.13}{140}}
\citation{peraisBeBop2015}
\citation{riley2006fpc}
\citation{peraisBeBop2015}
\@writefile{lot}{\contentsline {table}{\numberline {7.2}{\ignorespaces D-VTAGE table configuration and configurable parameters.\relax }}{141}}
\newlabel{tab:vtage-conf}{{7.2}{141}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.7.2}Setup}{141}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.7.3}Results}{142}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.14}{\ignorespaces Speedup obtained using a D-VTAGE value predictor and RRF with 16 cores composed. Baseline is 16 cores composed with SF and without value prediction. Both use perfect branch prediction. Higher is better.\relax }}{143}}
\newlabel{fig:vtage_perf}{{7.14}{143}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.15}{\ignorespaces Prediction coverage at a block and instruction level. Higher is better\relax }}{144}}
\newlabel{fig:vtag_cov_block}{{7.15}{144}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.16}{\ignorespaces Accuracy of the different D-VTAGE predictors at a block and instruction level. Higher is better.\relax }}{144}}
\newlabel{fig:vtag_accuracy_block}{{7.16}{144}}
\citation{peraisBeBop2015}
\citation{peraisVTAGE2014}
\@writefile{lot}{\contentsline {table}{\numberline {7.3}{\ignorespaces Branch prediction accuracy in percentage for each of the benchmarks.\relax }}{146}}
\newlabel{tab:sd-vbsbpred2}{{7.3}{146}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.17}{\ignorespaces Speedup obtained using a D-VTAGE value predictor and RRF with 16 cores composed. Baseline is 16 cores composed with SF and without value prediction. Both use a non-perfect branch predictor. Higher is better.\relax }}{146}}
\newlabel{fig:bpred}{{7.17}{146}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.7.4}Performance with non-perfect branch prediction}{146}}
\citation{peraisVTAGE2014}
\citation{peraisBeBop2015}
\newlabel{chp:chp3:sec:analysis2}{{7.7.4}{147}}
\@writefile{toc}{\contentsline {section}{\numberline {7.8}Conclusion}{147}}
\@setckpt{./chapter3/chapter3}{
\setcounter{page}{149}
\setcounter{equation}{0}
\setcounter{enumi}{0}
\setcounter{enumii}{0}
\setcounter{enumiii}{0}
\setcounter{enumiv}{0}
\setcounter{footnote}{0}
\setcounter{mpfootnote}{0}
\setcounter{part}{0}
\setcounter{chapter}{7}
\setcounter{section}{8}
\setcounter{subsection}{0}
\setcounter{subsubsection}{0}
\setcounter{paragraph}{0}
\setcounter{subparagraph}{0}
\setcounter{figure}{17}
\setcounter{table}{3}
\setcounter{ContinuedFloat}{0}
\setcounter{parentequation}{0}
\setcounter{KVtest}{0}
\setcounter{subfigure}{0}
\setcounter{subfigure@save}{0}
\setcounter{lofdepth}{1}
\setcounter{subtable}{0}
\setcounter{subtable@save}{0}
\setcounter{lotdepth}{1}
\setcounter{lips@count}{0}
\setcounter{lstnumber}{3}
\setcounter{AlgoLine}{0}
\setcounter{algocfline}{2}
\setcounter{algocfproc}{2}
\setcounter{algocf}{2}
\setcounter{ALG@line}{0}
\setcounter{ALG@rem}{0}
\setcounter{ALG@nested}{0}
\setcounter{ALG@Lnr}{2}
\setcounter{ALG@blocknr}{10}
\setcounter{ALG@storecount}{0}
\setcounter{ALG@tmpcounter}{0}
\setcounter{@stackindex}{0}
\setcounter{ROWcellindex@}{0}
\setcounter{r@tfl@t}{0}
\setcounter{@pps}{0}
\setcounter{@ppsavesec}{0}
\setcounter{@ppsaveapp}{0}
\setcounter{float@type}{8}
\setcounter{@todonotes@numberoftodonotes}{0}
\setcounter{lstlisting}{5}
}
