\relax 
\@writefile{toc}{\contentsline {chapter}{\numberline {7}Adapting hardware to improve core composition performance}{105}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{loa}{\addvspace {10\p@ }}
\newlabel{chp:hardchanges}{{7}{105}}
\@writefile{toc}{\contentsline {section}{\numberline {7.1}Introduction}{105}}
\newlabel{sect:introduction-chapter3}{{7.1}{105}}
\citation{peraisBeBop2015}
\citation{peraisBeBop2015}
\citation{sdvbs}
\@writefile{lof}{\contentsline {figure}{\numberline {7.1}{\ignorespaces Left: Speedup obtained when executing the MSER benchmark on different compositions and branch prediction accuracies. Right: Percentage of time (in cycles) cores in a composition execute instructions compared to the overall execution time. Higher is better for both.\relax }}{107}}
\newlabel{fig:mser_motiv}{{7.1}{107}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.2}{\ignorespaces Speedup obtained when on the MSER benchmark with different core composition with an oracle fetching scheme and perfect branch prediction. Higher is better. \relax }}{107}}
\newlabel{fig:motivation_fetch}{{7.2}{107}}
\@writefile{toc}{\contentsline {section}{\numberline {7.2}Motivation}{107}}
\newlabel{sect:ch3-motivation}{{7.2}{107}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.2.1}Branch prediction}{107}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.2.2}Fetching mechanism}{108}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.2.3}Data dependencies between blocks}{108}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {7.1}{\ignorespaces Example of loop found in MSER.\relax }}{109}}
\newlabel{lst:mser_snipet}{{7.1}{109}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {7.2}{\ignorespaces Example of how data-dependencies cause delays when executing four blocks in parallel. The blocks represent part of the loop body in Listing\nobreakspace  {}7.1\hbox {}.\relax }}{109}}
\newlabel{fig:mser_nvsited}{{7.2}{109}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.3}{\ignorespaces Speedup of executing \textit  {MSER} using the new fetching mechanism, with perfect value prediction and perfect branch prediction. Baseline is a single core with original branch prediction accuracy. Higher is better.\relax }}{109}}
\newlabel{fig:motivation_reg}{{7.3}{109}}
\citation{peraisVTAGE2014}
\@writefile{toc}{\contentsline {section}{\numberline {7.3}Round robin block fetching scheme}{110}}
\newlabel{chp3:sec:fetch}{{7.3}{110}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.3.1}Current fetching scheme}{110}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {7.3}{\ignorespaces Example of small loop.\relax }}{111}}
\newlabel{lst:basic}{{7.3}{111}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {7.4}{\ignorespaces Trace of when cores fetch blocks when executing Listing\nobreakspace  {}7.3\hbox {} on a 4 core composition. Y axis represents a core in the composition, X axis represents time.\relax }}{111}}
\newlabel{fig:fetch_norm}{{7.4}{111}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.3.2}Round Robin Fetching Scheme}{111}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {7.3.2.1}Generalised form}{111}}
\citation{SeznecMultipleBlock}
\@writefile{loa}{\contentsline {algocf}{\numberline {1}{\ignorespaces Overview of fetching algorithm for \textit  {n} cores fused\relax }}{113}}
\newlabel{alg:fetch}{{1}{113}}
\@writefile{loa}{\contentsline {algocf}{\numberline {2}{\ignorespaces Overview of commit stage for \textit  {n} cores fused\relax }}{114}}
\newlabel{alg:commit}{{2}{114}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.4}{\ignorespaces Example of RRF on a 2 core composition. Each core has 4 segments, the arrows represent the block generating the predictions.\relax }}{114}}
\newlabel{fig:new_fetch_ex}{{7.4}{114}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.5}{\ignorespaces Speedup when executing the synthetic block with varying execution times (facets) with SF and RRF. Higher is better.\relax }}{115}}
\newlabel{fig:motiv_res}{{7.5}{115}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.6}{\ignorespaces Average execution time (in cycles) of blocks for each of the SD-VBS benchmarks. Each benchmark was executed on a single core with a single lane with perfect branch prediction.\relax }}{115}}
\newlabel{fig:svdbs_av}{{7.6}{115}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.3.3}Evaluating the round robin fetch scheme on a synthetic block}{115}}
\@writefile{toc}{\contentsline {section}{\numberline {7.4}Value Predictor}{116}}
\citation{peraisVTAGE2014}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {7.5}{\ignorespaces Example of small loop.\relax }}{117}}
\newlabel{lst:basic2}{{7.5}{117}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {7.6}{\ignorespaces Overview of how a value predictor should work for EDGE. Prediction is made at the fetch stage, and predictions are used when register reads are dispatched.\relax }}{117}}
\newlabel{fig:bad_overview}{{7.6}{117}}
\citation{peraisBeBop2015}
\citation{peraisBeBop2015}
\citation{peraisBeBop2015}
\citation{peraisVTAGE2014}
\citation{peraisBeBop2015}
\citation{gabbayVPOrig}
\citation{goeman01dfcm}
\citation{peraisBeBop2015}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.4.1}Design features of a value predictor}{118}}
\citation{peraisBeBop2015}
\citation{peraisBeBop2015}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.4.2}Block based D-VTAGE predictor}{119}}
\citation{peraisBeBop2015}
\citation{sdvbs}
\newlabel{chp3:sec:val}{{7.4.2}{120}}
\@writefile{toc}{\contentsline {section}{\numberline {7.5}Experimental Setup}{120}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.5.1}Benchmarks}{120}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.5.2}Evaluation}{120}}
\citation{peraisVTAGE2014}
\citation{peraisBeBop2015}
\citation{sheikh2017value}
\citation{peraisBeBop2015}
\@writefile{lot}{\contentsline {table}{\numberline {7.1}{\ignorespaces Datasets used for each of the benchmarks.\relax }}{121}}
\newlabel{tab:sd-data2}{{7.1}{121}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.5.3}Value Predictor}{121}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.5.4}Implementing perfect value and branch predictor}{121}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.7}{\ignorespaces Overview of information gathering for generating traces which are used for the perfect branch and value predictors.\relax }}{122}}
\newlabel{fig:trace-gen}{{7.7}{122}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.8}{\ignorespaces Overview of how the trace data generated for value prediction is used during execution of a block.\relax }}{122}}
\newlabel{fig:trace-used}{{7.8}{122}}
\newlabel{chp:chp3:sec:exp}{{7.5.4}{122}}
\@writefile{toc}{\contentsline {section}{\numberline {7.6}Analysis using a perfect value prediction}{122}}
\newlabel{chp:chp3:sec:analysis}{{7.6}{122}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.9}{\ignorespaces Comparing the performance of serial fetch to round robin fetch, with and without perfect value prediction. Higher is better\relax }}{123}}
\newlabel{fig:perf_pred}{{7.9}{123}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.6.1}Analysing the performance of the different configurations}{123}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {7.6.1.1}Performance without value prediction}{123}}
\citation{peraisBeBop2015}
\@writefile{lof}{\contentsline {figure}{\numberline {7.10}{\ignorespaces Average time each core is executing blocks (in \%) for each benchmark, using the different configurations. Higher is better.\relax }}{124}}
\newlabel{fig:perf_av_cycle}{{7.10}{124}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {7.6.1.2}Performance with value prediction}{124}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.11}{\ignorespaces Number of blocks that cause LSQ violations, normalised by the number of fetched blocks for each of the benchmarks.\relax }}{125}}
\newlabel{fig:lsqvio}{{7.11}{125}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.6.2}Round robin fetching scheme bottleneck Analysis}{125}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.12}{\ignorespaces Average time (in cycles) for block to go from fetched to dispatched using the serial fetching scheme and round robin fetching scheme. Lower is better.\relax }}{126}}
\newlabel{fig:av_time}{{7.12}{126}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.13}{\ignorespaces Two core composition where cores fetch blocks of varying size. Green blocks represent blocks that can be dispatched, whilst the red blocks cannot.\relax }}{127}}
\newlabel{fig:var_ex}{{7.13}{127}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.14}{\ignorespaces Standard deviation of block sizes per benchmark.\relax }}{127}}
\newlabel{fig:variance}{{7.14}{127}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {7.6.2.1}Summary}{127}}
\citation{peraisBeBop2015}
\@writefile{lof}{\contentsline {figure}{\numberline {7.15}{\ignorespaces Average number of register reads and writes per EDGE block and the number of unique blocks comprising different percentages of the total execution (in blocks) of each of the benchmarks.\relax }}{128}}
\newlabel{fig:edge_reg_read}{{7.15}{128}}
\@writefile{toc}{\contentsline {section}{\numberline {7.7}Analysis using the block based D-VTAGE predictor}{128}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.7.1}Block analysis}{128}}
\@writefile{lot}{\contentsline {table}{\numberline {7.2}{\ignorespaces D-VTAGE table configuration and configurable parameters.\relax }}{129}}
\newlabel{tab:vtage-conf}{{7.2}{129}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.7.2}Setup}{129}}
\citation{peraisBeBop2015}
\citation{riley2006fpc}
\citation{peraisBeBop2015}
\@writefile{lof}{\contentsline {figure}{\numberline {7.16}{\ignorespaces Speedup obtained using a D-VTAGE value predictor and RRF with 16 cores composed. Baseline is 16 cores composed with SF and without value prediction. Both use perfect branch prediction. Higher is better.\relax }}{131}}
\newlabel{fig:vtage_perf}{{7.16}{131}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.7.3}Results}{131}}
\citation{peraisBeBop2015}
\citation{peraisVTAGE2014}
\@writefile{lof}{\contentsline {figure}{\numberline {7.17}{\ignorespaces Prediction coverage at a block and instruction level. Higher is better\relax }}{133}}
\newlabel{fig:vtag_cov_block}{{7.17}{133}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.18}{\ignorespaces Accuracy of the different D-VTAGE predictors at a block and instruction level. Higher is better.\relax }}{133}}
\newlabel{fig:vtag_accuracy_block}{{7.18}{133}}
\@writefile{lot}{\contentsline {table}{\numberline {7.3}{\ignorespaces Branch prediction accuracy in percentage for each of the benchmarks.\relax }}{134}}
\newlabel{tab:sd-vbsbpred2}{{7.3}{134}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.7.4}Performance with non-perfect branch prediction}{134}}
\@writefile{lof}{\contentsline {figure}{\numberline {7.19}{\ignorespaces Speedup obtained using a D-VTAGE value predictor and RRF with 16 cores composed. Baseline is 16 cores composed with SF and without value prediction. Both use a non-perfect branch predictor. Higher is better.\relax }}{135}}
\newlabel{fig:bpred}{{7.19}{135}}
\newlabel{chp:chp3:sec:analysis2}{{7.7.4}{135}}
\@writefile{toc}{\contentsline {section}{\numberline {7.8}Conclusion}{135}}
\citation{peraisVTAGE2014}
\citation{peraisBeBop2015}
\@setckpt{./chapter3/chapter3}{
\setcounter{page}{137}
\setcounter{equation}{0}
\setcounter{enumi}{0}
\setcounter{enumii}{0}
\setcounter{enumiii}{0}
\setcounter{enumiv}{0}
\setcounter{footnote}{0}
\setcounter{mpfootnote}{0}
\setcounter{part}{0}
\setcounter{chapter}{7}
\setcounter{section}{8}
\setcounter{subsection}{0}
\setcounter{subsubsection}{0}
\setcounter{paragraph}{0}
\setcounter{subparagraph}{0}
\setcounter{figure}{19}
\setcounter{table}{3}
\setcounter{ContinuedFloat}{0}
\setcounter{parentequation}{0}
\setcounter{KVtest}{0}
\setcounter{subfigure}{0}
\setcounter{subfigure@save}{0}
\setcounter{lofdepth}{1}
\setcounter{subtable}{0}
\setcounter{subtable@save}{0}
\setcounter{lotdepth}{1}
\setcounter{lips@count}{0}
\setcounter{lstnumber}{3}
\setcounter{AlgoLine}{0}
\setcounter{algocfline}{2}
\setcounter{algocfproc}{2}
\setcounter{algocf}{2}
\setcounter{ALG@line}{0}
\setcounter{ALG@rem}{0}
\setcounter{ALG@nested}{0}
\setcounter{ALG@Lnr}{2}
\setcounter{ALG@blocknr}{10}
\setcounter{ALG@storecount}{0}
\setcounter{ALG@tmpcounter}{0}
\setcounter{@stackindex}{0}
\setcounter{ROWcellindex@}{0}
\setcounter{r@tfl@t}{0}
\setcounter{@pps}{0}
\setcounter{@ppsavesec}{0}
\setcounter{@ppsaveapp}{0}
\setcounter{float@type}{8}
\setcounter{@todonotes@numberoftodonotes}{0}
\setcounter{lstlisting}{6}
}
